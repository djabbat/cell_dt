# Платформа Симуляции Дифференцировки Клеток Человека на Rust

> Спроектирована с упором на производительность, расширяемость и интеграцию с другими языками.

```
cell_dt/
├── Cargo.toml (workspace)
├── crates/
│   ├── cell_dt_core/          # Ядро платформы
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── components.rs  # Компоненты ECS (CentriolePair, PTMProfile, и т.д.)
│   │   │   ├── error.rs       # Типы ошибок
│   │   │   ├── module.rs      # Трейт SimulationModule
│   │   │   ├── simulation.rs  # SimulationManager
│   │   │   └── world.rs       # Расширения для World
│   ├── cell_dt_modules/
│   │   ├── centriole_module/   # Модуль центриоли (работает!)
│   │   ├── cell_cycle_module/  # Заготовка модуля клеточного цикла
│   │   └── transcriptome_module/ # Заготовка модуля транскриптома
│   ├── cell_dt_io/            # Заготовка модуля ввода/вывода
│   └── cell_dt_python/        # Заготовка Python биндингов
└── examples/
    └── src/bin/
                      # Usage examples
````

- `crates/cell_dt_core/` - ядро платформы (типажи, ECS, менеджер симуляции)
- `crates/cell_dt_modules/` - модули симуляции
  - `centriole_module/` - модуль центриоли (ПТМ, CAFD, возраст)
  - `cell_cycle_module/` - модуль клеточного цикла (в разработке)
  - `transcriptome_module/` - модуль транскриптома (в разработке)
- `crates/cell_dt_io/` - ввод/вывод данных (в разработке)
- `crates/cell_dt_python/` - Python-биндинги (в разработке)
- `examples/` - примеры использования

## Быстрый старт

```bash
# Сборка проекта
cargo build

# Запуск примера
cargo run --example simple_simulation

---

## 1. Введение и философия проекта

### 1.1. Цель
Создать высокопроизводительную, модульную и расширяемую платформу для симуляции клеточной дифференцировки, которая явным образом моделирует центриоль как ключевой регуляторный хаб. Платформа должна служить **Цифровым Двойником (Digital Twin)** для экспериментов и позволять интегрировать данные с экспериментов, проводить *in silico* скрининг и проверять гипотезы.

### 1.2. Ключевые требования
1.  **Производительность:** Симуляция популяций в `10^5`-`10^6` клеток с детальными внутриклеточными моделями.
2.  **Модульность:** Возможность легко заменять или улучшать отдельные модули (модель центриоли, сигнальный путь, метаболизм) без переписывания всей платформы.
3.  **Расширяемость:** Поддержка плагинов и возможность вызова вычислений на других языках (Python, C/C++, Julia) для использования существующих научных библиотек.
4.  **Интеграция данных:** Наличие четких интерфейсов для загрузки экспериментальных данных (scRNA-seq, данные микроскопии) и калибровки модели.
5.  **Воспроизводимость:** Фиксация всех параметров симуляции и версий модулей для полной воспроизводимости результатов.

### 1.3. Почему Rust?
*   **Безопасность памяти:** Предотвращает целый класс ошибок, критичных для долгих, сложных симуляций.
*   **Производительность на уровне C/C++:** Необходима для агент-ориентированного моделирования (ABM) больших популяций.
*   **Богатая экосистема для научных вычислений:** `ndarray`, `nalgebra`, `rayon` (параллелизм), `plotters`.
*   **Превосходная интероперабельность:** Легкий и безопасный вызов функций из C (и, через C, из Python/Julia), что соответствует требованию №3.
*   **Активное сообщество и современные инструменты:** Cargo, тестирование, бенчмаркинг.

## 2. Архитектура платформы

Платформа будет построена по многоуровневому принципу, строго следуя логике, изложенной в главе 4 "Методы.md".

```text
+-----------------------------------------------------------------------------------+
|                           УРОВЕНЬ ПОЛЬЗОВАТЕЛЯ                                    |
|  (CLI, Веб-интерфейс, Jupyter Notebook (via Py03), Визуализатор)                 |
+---------------------------------------^-------------------------------------------+
                                        | (API вызовы)
+---------------------------------------v-------------------------------------------+
|                         ЯДРО ПЛАТФОРМЫ (Rust Core)                                |
|  +-----------------------------------------------------------------------------+  |
|  | Менеджер симуляции (Simulation Orchestrator)                                |  |
|  | - Управление временным циклом (дискретные шаги)                             |  |
|  | - Планировщик событий                                                        |  |
|  | - Конфигурация и валидация параметров                                       |  |
|  +------------------------------------^----------------------------------------+  |
|                                       | (взаимодействие через типажи)            |
|  +------------------------------------v----------------------------------------+  |
|  |                     МОДУЛИ СИМУЛЯЦИИ (Plugins/Modules)                      |  |
|  |  [X]                [X]                 [X]               [X]              |  |
|  | Модуль A:      Модуль B:          Модуль C:          Модуль D:           |  |
|  | Клеточный цикл  Центриоль         Сигнальные пути    Транскриптом           |  |
|  |                 (КАРКАС)                                                     |  |
|  +------------------------------------^----------------------------------------+  |
|                                       | (in-memory)                              |
|  +------------------------------------v----------------------------------------+  |
|  |                   МЕНЕДЖЕР СОСТОЯНИЙ (State Manager)                          |  |
|  | - ECS (Entity-Component System) для хранения всех клеток и молекул          |  |
|  | - Хранение глобальных переменных (концентрации морфогенов)                  |  |
|  +------------------------------------^----------------------------------------+  |
|                                       | (запись/чтение)                           |
|  +------------------------------------v----------------------------------------+  |
|  |                      МЕНЕДЖЕР ДАННЫХ (Data Manager)                           |  |
|  | - Интерфейсы для загрузки данных (CSV, HDF5, Parquet)                        |  |
|  | - Запись результатов симуляции (HDF5, Arrow)                                 |  |
|  | - Сохранение/загрузка состояния симуляции (чекпоинты)                         |  |
+---------------------------------------^-------------------------------------------+
                                        | (вызовы через FFI)
+---------------------------------------v-------------------------------------------+
|                     ИНТЕГРАЦИЯ С ДРУГИМИ ЯЗЫКАМИ (FFI Layer)                     |
|  +----------------------+ +----------------------+ +----------------------+     |
|  | Python Bindings      | | C/Fortran Libraries  | | Julia/WASM/...       |     |
|  | (PyO3)               | | (extern C)           | | (расширяемость)      |     |
|  +----------------------+ +----------------------+ +----------------------+     |
+-----------------------------------------------------------------------------------+
```

### 2.1. Ядро платформы (Rust Core)
*   **Менеджер симуляции:** Сердце платформы. Содержит главный цикл `for step in 0..max_steps`. На каждом шаге он последовательно вызывает зарегистрированные модули. Отвечает за параллельное выполнение (`rayon`).
*   **ECS (Entity-Component System):** Ключевой паттерн для производительности ABM. Мы будем использовать крейт `hecs` или `specs`.
    *   **Сущность (Entity):** Уникальный идентификатор клетки.
    *   **Компоненты (Components):** Простые структуры данных, хранящие состояние.
        ```rust
        // Компоненты клетки
        struct Position { x: f32, y: f32, z: f32 }
        struct Polarity { dx: f32, dy: f32, dz: f32 }
        struct GeneExpression { profile: HashMap<String, f32> } // Или фиксированный массив
        struct CellCycleState { phase: Phase, progress: f32 }

        // ЦЕНТРИОЛЯРНЫЙ МОДУЛЬ (Core Centriole State)
        struct CentriolePair {
            mother: Centriole,
            daughter: Centriole,
            cilium_present: bool,
            mtoc_activity: f32,
        }

        struct Centriole {
            maturity: f32, // 0.0 (новая) - 1.0 (зрелая)
            associated_cafds: Vec<CAFD>,
            ptm_signature: PTMProfile, // <-- Прямое отражение идей из диссертации
        }

        struct PTMProfile {
            acetylation_level: f32,
            oxidation_level: f32,
            // ... другие модификации
        }

        struct CAFD {
            name: String, // "YAP", "STAT3"
            activity: f32,
        }
        ```
    *   **Системы (Systems):** Функции, которые работают с компонентами. Например, `centriole_system` будет проходиться по всем клеткам, у которых есть компонент `CentriolePair`, и обновлять его состояние на основе других компонентов и правил.

### 2.2. Модули симуляции (Plugins)
Каждый модуль — это отдельный крейт (crate), который реализует заданный типаж (`trait`). Это обеспечивает модульность.

```rust
// В ядре определен типаж
pub trait SimulationModule {
    fn name(&self) -> &str;
    fn step(&mut self, world: &mut World, dt: f64) -> Result<(), ModuleError>;
    fn get_params(&self) -> serde_json::Value; // Для верификации и чекпоинтов
    // ...
}

// Модуль "Центриоль" (крейт centriole_module)
use simulation_core::*;
struct CentrioleModule { /* параметры модели: скорость ацетилирования и т.д. */ }

impl SimulationModule for CentrioleModule {
    fn step(&mut self, world: &mut World, dt: f64) {
        // Параллельно обновляем состояние всех центриолей
        use rayon::prelude::*;
        let mut query = world.query::<(&mut CentriolePair, &CellCycleState)>();
        query.par_iter_mut(world).for_each(|(centriole_pair, cell_cycle)| {
            // 1. Обновить maturity на основе cell_cycle
            // 2. Обновить PTM_signature на основе внутренних правил и внешних стрессов
            // 3. Обновить список associated_cafds (может вызывать Python-модель через FFI)
            // 4. Рассчитать mtoc_activity
        });
    }
    // ...
}
```

### 2.3. Менеджер данных
*   **Входные данные:** Загрузка экспериментальных данных (например, `scRNA-seq` профилей) для инициализации компонента `GeneExpression` у клеток.
*   **Выходные данные:** Запись состояния всех (или выбранных) клеток на каждом шаге или с заданным интервалом. Формат **Apache Arrow** идеален, так как обеспечивает высокую производительность и может быть напрямую прочитан из Python/Pandas для анализа. HDF5 также поддерживается.
*   **Чекпоинты:** Сохранение полного состояния мира (`World`) в бинарном формате (`bincode` или `postcard`) для возможности продолжить симуляцию позже.

### 2.4. Уровень интеграции с другими языками (FFI)
*   **Python (PyO3):** Самый важный бэкенд. Позволит:
    *   Загружать и предобрабатывать данные (Pandas, Scanpy) перед передачей в симуляцию.
    *   Использовать Python-модели для сложных внутриклеточных процессов (например, предсказание связывания CAFD с помощью обученной GNN на PyTorch).
    *   Управлять симуляцией из Jupyter Notebook.
    *   Визуализировать результаты (Matplotlib, Plotly).
*   **C ABI (`extern "C"`):** Позволяет вызывать высокопроизводительные библиотеки, написанные на C/C++/Fortran (например, решатели жестких систем ОДУ из SUNDIALS, библиотеки линейной алгебры). Rust-код может легко их вызывать.
*   **Julia (через C):** Для подключения моделей, написанных на Julia, если это потребуется.

## 3. Детальный план разработки (Этапы)

### Этап 1: Фундамент и Минимальная жизнеспособная модель (Год 1)
**Цель:** Создать работающую платформу, способную симулировать упрощенную версию эксперимента A1 из диссертации.
1.  **Проектирование ядра:** Определение типажей `SimulationModule`, `DataLoader`, `DataWriter`. Настройка ECS (`hecs`).
2.  **Реализация базовых модулей:**
    *   `cell_cycle_module`: Упрощенная модель клеточного цикла (G1, S, G2, M).
    *   `centriole_module_0`: Базовая модель центриоли, отслеживающая только `maturity` (возраст). Включает простое правило: при митозе старая материнская остается, новая дочерняя создается с `maturity = 0`.
    *   `transcription_module_0`: Очень простая модель: экспрессия генов зависит только от фазы клеточного цикла.
3.  **Интеграция с данными:** Простой загрузчик CSV для инициализации клеток.
4.  **Тестовая симуляция:** Запуск симуляции небольшой популяции клеток (1000) на 100 временных шагов.
5.  **Python-бэкенд (PyO3):** Создание базовых биндингов для запуска симуляции и получения агрегированных результатов (средний возраст центриолей, распределение по фазам цикла).

### Этап 2: Усложнение модели и FFI (Год 2)
**Цель:** Интегрировать более реалистичные модели и начать верификацию с экспериментальными данными (Эксперимент A1, B1).
1.  **Модуль "Центриолярные ПТМ":** Реализация `centriole_module_1`, который отслеживает `PTMProfile`. Правила накопления ПТМ могут быть загружены из Python или описаны в конфигурации.
2.  **Модуль "Сигнальные пути":** Начальная реализация путей Wnt и TGF-β. Критически важный момент: эти пути должны взаимодействовать с `CentriolePair` (например, рекрутирование CAFD).
3.  **Интеграция с Python для ML:**
    *   Модуль "Transcription" вызывает Python-функцию (через PyO3). На вход подается состояние клетки (`GeneExpression`, активность сигнальных путей, состояние центриоли). На выходе — обновленный профиль экспрессии.
    *   Это позволяет использовать нейросеть, обученную на реальных данных scRNA-seq для предсказания следующего состояния транскриптома.
4.  **Интеграция с C для ОДУ:** Использование `sundials` (через `sundials-sys`) для точного решения кинетики внутриклеточных реакций.
5.  **Верификация:** Попытка воспроизвести корреляцию, найденную в эксперименте B1 ("старые" центриоли коррелируют с маркерами старения) *in silico*.

### Этап 3: Полноценный Цифровой Двойник (Годы 3-4)
**Цель:** Платформа, способная предсказывать исходы "слепых" экспериментов (как в A2) и предлагать стратегии "центриоло-ревитализации".
1.  **Модуль "Пространство":** Добавление компонента `Position`. Реализация диффузии морфогенов (PDE) на сетке (гибридная ABM+PDE модель). Клетки могут взаимодействовать через паракринные сигналы.
2.  **Визуализация в реальном времени:** Создание простого 3D-визуализатора (например, на `kiss3d` или отправка данных в Unity через сокеты) для наблюдения за симуляцией.
3.  **Интеграция с имиджинговыми данными:** Модуль, который может "визуализировать" внутреннее состояние клетки, имитируя выходные данные микроскопии (например, генерировать синтетические изображения Centrin на основе состояния `CentriolePair`). Это ключ к прямому сравнению с экспериментальными данными из диссертации.
4.  **Язык описания экспериментов (DSL):** Создание простого предметно-ориентированного языка на Rust или TOML, позволяющего описывать протокол дифференцировки ("День 0: добавить фактор X. День 3: добавить ингибитор Y") и запускать симуляцию.
5.  **Оптимизация и бенчмаркинг:** Профилирование кода, оптимизация узких мест, масштабирование на несколько ядер/узлов.

## 4. Ключевые технологические решения

*   **Параллелизм:** `rayon` для data-parallel операций над клетками. Для более сложной координации — каналы `crossbeam`.
*   **ECS:** `hecs` за его простоту и скорость. `specs` более функционален, но сложнее.
*   **Научные вычисления:** `ndarray` с поддержкой BLAS/LAPACK.
*   **Формат данных:** `arrow` и `parquet` для эффективного обмена с Python-экосистемой. `hdf5` (крейт `hdf5`) для совместимости со старыми инструментами.
*   **FFI:** `pyo3` для Python. `cbindgen` для генерации C-заголовков.
*   **Визуализация:** `plotters` для быстрых 2D-графиков. Для 3D — интеграция с внешними инструментами.

## 5. Вывод: Как эта платформа поддерживает диссертацию

Предлагаемая платформа на Rust станет не просто "еще одной программой", а центральным инструментом, реализующим итеративный цикл "Эксперимент -> Модель -> Предсказание -> Эксперимент", описанный в "Критическом анализе".

1.  **Интеграция данных:** Платформа будет напрямую потреблять данные из Эксперимента A1 (scRNA-seq, IMC) для инициализации и калибровки моделей.
2.  **Проверка гипотез:** Модуль `Centriole` с его `PTMProfile` позволит *in silico* проверить центральную гипотезу диссертации, прежде чем ставить сложные эксперименты B2.
3.  **Предсказательная сила:** Используя гибридные модели (ABM + ML из Python), платформа сможет предсказать результаты экспериментов A2 и C1, направляя экспериментальную работу и экономя ресурсы.
4.  **Терапевтический дизайн:** Модуль "центриоло-ревитализации" (на основе данных из C1) может быть реализован и протестирован *in silico* для оптимизации доз и мишеней перед дорогостоящими экспериментами на животных (C2).
5.  **Объединяющая теория:** Успешная симуляция, воспроизводящая результаты всех трех уровней доказательств (корреляция, причинность, терапия), станет мощнейшим аргументом в пользу выдвигаемой "центриолярной теории времени".